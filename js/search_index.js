var search_data = {"index":{"searchIndex":["duckdb","appender","blob","column","config","connection","database","error","extractedstatements","extractedstatementsimpl","infinity","instancecache","interval","logicaltype","pendingresult","preparedstatement","result","==()","[]=()","_internal_type()","alias()","alias=()","append()","append_blob()","append_bool()","append_date()","append_default()","append_double()","append_float()","append_hugeint()","append_int16()","append_int32()","append_int64()","append_int8()","append_interval()","append_null()","append_row()","append_time()","append_timestamp()","append_uhugeint()","append_uint16()","append_uint32()","append_uint64()","append_uint8()","append_varchar()","append_varchar_length()","appender()","async_query()","async_query_stream()","begin_row()","bind()","bind_args()","bind_blob()","bind_bool()","bind_date()","bind_decimal()","bind_double()","bind_float()","bind_hugeint()","bind_hugeint_internal()","bind_int16()","bind_int32()","bind_int64()","bind_int8()","bind_interval()","bind_null()","bind_parameter_index()","bind_time()","bind_timestamp()","bind_uhugeint()","bind_uint16()","bind_uint32()","bind_uint64()","bind_uint8()","bind_varchar()","child_count()","child_name_at()","child_type()","child_type_at()","clear_bindings()","close()","close()","column_count()","column_size()","columns()","connect()","connect()","destroy()","destroy()","dictionary_size()","dictionary_value_at()","disconnect()","each()","each()","each_child_name()","each_child_type()","each_dictionary_value()","each_member_name()","each_member_type()","end_row()","eql?()","error_message()","execute()","execute_check_state()","execute_pending()","execute_task()","execution_finished?()","flush()","get_alias()","get_config_flag()","internal_type()","interrupt()","iso8601_parse()","key_description()","key_descriptions()","key_type()","library_version()","logical_type()","member_count()","member_name_at()","member_type_at()","mk_interval()","name()","new()","new()","new()","new()","new()","new()","new()","new()","new()","nparams()","open()","param_type()","parameter_name()","pending_prepared()","pending_prepared_stream()","prepare()","prepared_statement()","prepared_statement()","query()","query_multi_sql()","query_progress()","rows_changed()","scale()","set_alias()","set_config()","size()","size()","size()","state()","statement_type()","to_interval()","type()","type()","use_chunk_each?()","value_type()","width()","changelog","contribution","license","readme"],"longSearchIndex":["duckdb","duckdb::appender","duckdb::blob","duckdb::column","duckdb::config","duckdb::connection","duckdb::database","duckdb::error","duckdb::extractedstatements","duckdb::extractedstatementsimpl","duckdb::infinity","duckdb::instancecache","duckdb::interval","duckdb::logicaltype","duckdb::pendingresult","duckdb::preparedstatement","duckdb::result","duckdb::interval#==()","duckdb::config#[]=()","duckdb::logicaltype#_internal_type()","duckdb::logicaltype#alias()","duckdb::logicaltype#alias=()","duckdb::appender#append()","duckdb::appender#append_blob()","duckdb::appender#append_bool()","duckdb::appender#append_date()","duckdb::appender#append_default()","duckdb::appender#append_double()","duckdb::appender#append_float()","duckdb::appender#append_hugeint()","duckdb::appender#append_int16()","duckdb::appender#append_int32()","duckdb::appender#append_int64()","duckdb::appender#append_int8()","duckdb::appender#append_interval()","duckdb::appender#append_null()","duckdb::appender#append_row()","duckdb::appender#append_time()","duckdb::appender#append_timestamp()","duckdb::appender#append_uhugeint()","duckdb::appender#append_uint16()","duckdb::appender#append_uint32()","duckdb::appender#append_uint64()","duckdb::appender#append_uint8()","duckdb::appender#append_varchar()","duckdb::appender#append_varchar_length()","duckdb::connection#appender()","duckdb::connection#async_query()","duckdb::connection#async_query_stream()","duckdb::appender#begin_row()","duckdb::preparedstatement#bind()","duckdb::preparedstatement#bind_args()","duckdb::preparedstatement#bind_blob()","duckdb::preparedstatement#bind_bool()","duckdb::preparedstatement#bind_date()","duckdb::preparedstatement#bind_decimal()","duckdb::preparedstatement#bind_double()","duckdb::preparedstatement#bind_float()","duckdb::preparedstatement#bind_hugeint()","duckdb::preparedstatement#bind_hugeint_internal()","duckdb::preparedstatement#bind_int16()","duckdb::preparedstatement#bind_int32()","duckdb::preparedstatement#bind_int64()","duckdb::preparedstatement#bind_int8()","duckdb::preparedstatement#bind_interval()","duckdb::preparedstatement#bind_null()","duckdb::preparedstatement#bind_parameter_index()","duckdb::preparedstatement#bind_time()","duckdb::preparedstatement#bind_timestamp()","duckdb::preparedstatement#bind_uhugeint()","duckdb::preparedstatement#bind_uint16()","duckdb::preparedstatement#bind_uint32()","duckdb::preparedstatement#bind_uint64()","duckdb::preparedstatement#bind_uint8()","duckdb::preparedstatement#bind_varchar()","duckdb::logicaltype#child_count()","duckdb::logicaltype#child_name_at()","duckdb::logicaltype#child_type()","duckdb::logicaltype#child_type_at()","duckdb::preparedstatement#clear_bindings()","duckdb::appender#close()","duckdb::database#close()","duckdb::result#column_count()","duckdb::result#column_size()","duckdb::result#columns()","duckdb::connection#connect()","duckdb::database#connect()","duckdb::extractedstatementsimpl#destroy()","duckdb::instancecache#destroy()","duckdb::logicaltype#dictionary_size()","duckdb::logicaltype#dictionary_value_at()","duckdb::connection#disconnect()","duckdb::extractedstatements#each()","duckdb::result#each()","duckdb::logicaltype#each_child_name()","duckdb::logicaltype#each_child_type()","duckdb::logicaltype#each_dictionary_value()","duckdb::logicaltype#each_member_name()","duckdb::logicaltype#each_member_type()","duckdb::appender#end_row()","duckdb::interval#eql?()","duckdb::appender#error_message()","duckdb::preparedstatement#execute()","duckdb::pendingresult#execute_check_state()","duckdb::pendingresult#execute_pending()","duckdb::pendingresult#execute_task()","duckdb::pendingresult#execution_finished?()","duckdb::appender#flush()","duckdb::logicaltype#get_alias()","duckdb::config::get_config_flag()","duckdb::logicaltype#internal_type()","duckdb::connection#interrupt()","duckdb::interval::iso8601_parse()","duckdb::config::key_description()","duckdb::config::key_descriptions()","duckdb::logicaltype#key_type()","duckdb::library_version()","duckdb::column#logical_type()","duckdb::logicaltype#member_count()","duckdb::logicaltype#member_name_at()","duckdb::logicaltype#member_type_at()","duckdb::interval::mk_interval()","duckdb::column#name()","duckdb::appender::new()","duckdb::config::new()","duckdb::extractedstatements::new()","duckdb::extractedstatementsimpl::new()","duckdb::instancecache::new()","duckdb::interval::new()","duckdb::pendingresult::new()","duckdb::preparedstatement::new()","duckdb::result::new()","duckdb::preparedstatement#nparams()","duckdb::database::open()","duckdb::preparedstatement#param_type()","duckdb::preparedstatement#parameter_name()","duckdb::preparedstatement#pending_prepared()","duckdb::preparedstatement#pending_prepared_stream()","duckdb::preparedstatement::prepare()","duckdb::connection#prepared_statement()","duckdb::extractedstatementsimpl#prepared_statement()","duckdb::connection#query()","duckdb::connection#query_multi_sql()","duckdb::connection#query_progress()","duckdb::result#rows_changed()","duckdb::logicaltype#scale()","duckdb::logicaltype#set_alias()","duckdb::config#set_config()","duckdb::config::size()","duckdb::extractedstatementsimpl#size()","duckdb::logicaltype#size()","duckdb::pendingresult#state()","duckdb::preparedstatement#statement_type()","duckdb::interval::to_interval()","duckdb::column#type()","duckdb::logicaltype#type()","duckdb::result::use_chunk_each?()","duckdb::logicaltype#value_type()","duckdb::logicaltype#width()","","","",""],"info":[["DuckDB","","DuckDB.html","","<p>DuckDB provides Ruby interface of DuckDB.\n"],["DuckDB::Appender","","DuckDB/Appender.html","","<p>The DuckDB::Appender encapsulates DuckDB Appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">con</span> = <span class=\"ruby-identifier\">db</span>.<span class=\"ruby-identifier\">connect</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DuckDB::Blob","","DuckDB/Blob.html","",""],["DuckDB::Column","","DuckDB/Column.html","",""],["DuckDB::Config","","DuckDB/Config.html","","<p>The DuckDB::Config encapsulates DuckDB Configuration.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">config</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Config</span>.<span class=\"ruby-identifier\">new</span>\n<span class=\"ruby-identifier\">config</span>[<span class=\"ruby-string\">&#39;default_order&#39;</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DuckDB::Connection","","DuckDB/Connection.html","","<p>The DuckDB::Connection encapsulates connection with DuckDB database.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DuckDB::Database","","DuckDB/Database.html","","<p>The Database class encapsulates a DuckDB database.\n<p>The usage is as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DuckDB::Error","","DuckDB/Error.html","",""],["DuckDB::ExtractedStatements","","DuckDB/ExtractedStatements.html","",""],["DuckDB::ExtractedStatementsImpl","","DuckDB/ExtractedStatementsImpl.html","",""],["DuckDB::Infinity","","DuckDB/Infinity.html","",""],["DuckDB::InstanceCache","","DuckDB/InstanceCache.html","",""],["DuckDB::Interval","","DuckDB/Interval.html","","<p>Interval class represents DuckDB’s interval type value.\n<p>The usage is as follows:\n\n<pre>require &#39;duckdb&#39;\n ...</pre>\n"],["DuckDB::LogicalType","","DuckDB/LogicalType.html","",""],["DuckDB::PendingResult","","DuckDB/PendingResult.html","","<p>The DuckDB::PendingResult encapsulates connection with DuckDB pending result. PendingResult provides …\n"],["DuckDB::PreparedStatement","","DuckDB/PreparedStatement.html","","<p>The DuckDB::PreparedStatement encapsulates connection with DuckDB prepared statement.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["DuckDB::Result","","DuckDB/Result.html","","<p>The Result class encapsulates a execute result of DuckDB database.\n<p>The usage is as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["==","DuckDB::Interval","DuckDB/Interval.html#method-i-3D-3D","(other)",""],["[]=","DuckDB::Config","DuckDB/Config.html#method-i-5B-5D-3D","(p1, p2)","<p>set configuration value\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">config</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Config</span>.<span class=\"ruby-identifier\">new</span>\n<span class=\"ruby-comment\"># config.set_config(&#39;default_order&#39;, &#39;DESC&#39;)</span>\n<span class=\"ruby-identifier\">config</span>[<span class=\"ruby-string\">&#39;default_order&#39;</span>] <span class=\"ruby-operator\">...</span>\n</pre>\n"],["_internal_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-_internal_type","()","<p>Returns the logical type’s internal type.\n"],["alias","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-alias","()",""],["alias=","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-alias-3D","(p1)",""],["append","DuckDB::Appender","DuckDB/Appender.html#method-i-append","(value)","<p>appends value.\n\n<pre>require &#39;duckdb&#39;\ndb = DuckDB::Database.open\ncon = db.connect\ncon.query(&#39;CREATE TABLE users ...</pre>\n"],["append_blob","DuckDB::Appender","DuckDB/Appender.html#method-i-append_blob","(value)","<p>Appends a varchar value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_bool","DuckDB::Appender","DuckDB/Appender.html#method-i-append_bool","(value)","<p>Appends a boolean value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_date","DuckDB::Appender","DuckDB/Appender.html#method-i-append_date","(value)","<p>Appends a date value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">con</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_default","DuckDB::Appender","DuckDB/Appender.html#method-i-append_default","()","<p>Appends a default value to the current row in the appender. If the column does not have a default value, …\n"],["append_double","DuckDB::Appender","DuckDB/Appender.html#method-i-append_double","(value)","<p>Appends a double value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_float","DuckDB::Appender","DuckDB/Appender.html#method-i-append_float","(value)","<p>Appends a float value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_hugeint","DuckDB::Appender","DuckDB/Appender.html#method-i-append_hugeint","(value)","<p>Appends a huge int value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_int16","DuckDB::Appender","DuckDB/Appender.html#method-i-append_int16","(value)","<p>Appends an int16(SMALLINT) value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_int32","DuckDB::Appender","DuckDB/Appender.html#method-i-append_int32","(value)","<p>Appends an int32(INTEGER) value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_int64","DuckDB::Appender","DuckDB/Appender.html#method-i-append_int64","(value)","<p>Appends an int64(BIGINT) value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_int8","DuckDB::Appender","DuckDB/Appender.html#method-i-append_int8","(value)","<p>Appends an int8(TINYINT) value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_interval","DuckDB::Appender","DuckDB/Appender.html#method-i-append_interval","(value)","<p>Appends an interval value to the current row in the appender. The argument must be ISO8601 duration format. …\n"],["append_null","DuckDB::Appender","DuckDB/Appender.html#method-i-append_null","()","<p>Appends a NULL value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">con</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_row","DuckDB::Appender","DuckDB/Appender.html#method-i-append_row","(*args)","<p>append a row.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">appender</span>.<span class=\"ruby-identifier\">append_row</span>(<span class=\"ruby-value\">1</span>, <span class=\"ruby-string\">&#39;Alice&#39;</span>)\n</pre>\n<p>is same as:\n"],["append_time","DuckDB::Appender","DuckDB/Appender.html#method-i-append_time","(value)","<p>Appends a time value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">con</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_timestamp","DuckDB::Appender","DuckDB/Appender.html#method-i-append_timestamp","(value)","<p>Appends a timestamp value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_uhugeint","DuckDB::Appender","DuckDB/Appender.html#method-i-append_uhugeint","(value)","<p>Appends an unsigned huge int value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_uint16","DuckDB::Appender","DuckDB/Appender.html#method-i-append_uint16","(value)","<p>Appends an uint16 value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_uint32","DuckDB::Appender","DuckDB/Appender.html#method-i-append_uint32","(value)","<p>Appends an uint32 value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_uint64","DuckDB::Appender","DuckDB/Appender.html#method-i-append_uint64","(value)","<p>Appends an uint64 value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_uint8","DuckDB::Appender","DuckDB/Appender.html#method-i-append_uint8","(value)","<p>Appends an uint8 value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_varchar","DuckDB::Appender","DuckDB/Appender.html#method-i-append_varchar","(value)","<p>Appends a varchar value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["append_varchar_length","DuckDB::Appender","DuckDB/Appender.html#method-i-append_varchar_length","(value, length)","<p>Appends a varchar value to the current row in the appender.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["appender","DuckDB::Connection","DuckDB/Connection.html#method-i-appender","(table)","<p>returns Appender object. The first argument is table name\n"],["async_query","DuckDB::Connection","DuckDB/Connection.html#method-i-async_query","(sql, *args, **kwargs)","<p>executes sql with args asynchronously. The first argument sql must be SQL string. The rest arguments …\n"],["async_query_stream","DuckDB::Connection","DuckDB/Connection.html#method-i-async_query_stream","(sql, *args, **kwargs)","<p>executes sql with args asynchronously and provides streaming result. The first argument sql must be  …\n"],["begin_row","DuckDB::Appender","DuckDB/Appender.html#method-i-begin_row","()",""],["bind","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_args","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_args","(*args, **kwargs)","<p>binds all parameters with SQL prepared statement.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>(<span class=\"ruby-string\">&#39;duckdb_database&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["bind_blob","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_blob","(p1, p2)",""],["bind_bool","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_bool","(p1, p2)",""],["bind_date","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_date","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_decimal","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_decimal","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_double","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_double","(p1, p2)",""],["bind_float","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_float","(p1, p2)",""],["bind_hugeint","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_hugeint","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_hugeint_internal","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_hugeint_internal","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_int16","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_int16","(p1, p2)",""],["bind_int32","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_int32","(p1, p2)",""],["bind_int64","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_int64","(p1, p2)",""],["bind_int8","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_int8","(p1, p2)",""],["bind_interval","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_interval","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_null","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_null","(p1)",""],["bind_parameter_index","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_parameter_index","(p1)",""],["bind_time","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_time","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_timestamp","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_timestamp","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_uhugeint","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_uhugeint","(index, value)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_uint16","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_uint16","(index, val)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_uint32","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_uint32","(index, val)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_uint64","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_uint64","(index, val)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_uint8","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_uint8","(index, val)","<p>binds i-th parameter with SQL prepared statement. The first argument is index of parameter. The index …\n"],["bind_varchar","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-bind_varchar","(p1, p2)",""],["child_count","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-child_count","()","<p>Returns the number of children of a struct type, otherwise 0.\n"],["child_name_at","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-child_name_at","(p1)","<p>Returns the name of the struct child at the specified index.\n"],["child_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-child_type","()","<p>Returns the child logical type for list and map types, otherwise nil.\n"],["child_type_at","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-child_type_at","(p1)","<p>Returns the child logical type for struct types at the specified index as a DuckDB::LogicalType object. …\n"],["clear_bindings","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-clear_bindings","()","<p>clear all bindings of prepared statement.\n"],["close","DuckDB::Appender","DuckDB/Appender.html#method-i-close","()","<p>Closes the appender by flushing all intermediate states and closing it for further appends. If flushing …\n"],["close","DuckDB::Database","DuckDB/Database.html#method-i-close","()","<p>closes DuckDB database.\n"],["column_count","DuckDB::Result","DuckDB/Result.html#method-i-column_count","()","<p>Returns the column size of the result.\n\n<pre>DuckDB::Database.open do |db|\n  db.connect do |con|\n    r = con.query(&#39;CREATE ...</pre>\n"],["column_size","DuckDB::Result","DuckDB/Result.html#method-i-column_size","()",""],["columns","DuckDB::Result","DuckDB/Result.html#method-i-columns","()","<p>Returns the column class Lists.\n"],["connect","DuckDB::Connection","DuckDB/Connection.html#method-i-connect","(db)","<p>connects DuckDB database The first argument is DuckDB::Database object\n"],["connect","DuckDB::Database","DuckDB/Database.html#method-i-connect","()","<p>connects database.\n<p>The method yields block and disconnects the database if block given\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["destroy","DuckDB::ExtractedStatementsImpl","DuckDB/ExtractedStatementsImpl.html#method-i-destroy","()",""],["destroy","DuckDB::InstanceCache","DuckDB/InstanceCache.html#method-i-destroy","()",""],["dictionary_size","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-dictionary_size","()","<p>Returns the dictionary size of the enum type.\n"],["dictionary_value_at","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-dictionary_value_at","(p1)","<p>Returns the dictionary value at the specified index.\n"],["disconnect","DuckDB::Connection","DuckDB/Connection.html#method-i-disconnect","()",""],["each","DuckDB::ExtractedStatements","DuckDB/ExtractedStatements.html#method-i-each","()",""],["each","DuckDB::Result","DuckDB/Result.html#method-i-each","(&)",""],["each_child_name","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-each_child_name","()","<p>Iterates over each struct child name.\n<p>When a block is provided, this method yields each struct child name …\n"],["each_child_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-each_child_type","()","<p>Iterates over each struct child type.\n<p>When a block is provided, this method yields each struct child type …\n"],["each_dictionary_value","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-each_dictionary_value","()","<p>Iterates over each enum dictionary value.\n<p>When a block is provided, this method yields each enum dictionary …\n"],["each_member_name","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-each_member_name","()","<p>Iterates over each union member name.\n<p>When a block is provided, this method yields each union member name …\n"],["each_member_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-each_member_type","()","<p>Iterates over each union member type.\n<p>When a block is provided, this method yields each union member logical …\n"],["end_row","DuckDB::Appender","DuckDB/Appender.html#method-i-end_row","()","<p>Finish the current row of appends. After end_row is called, the next row can be appended.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["eql?","DuckDB::Interval","DuckDB/Interval.html#method-i-eql-3F","(other)",""],["error_message","DuckDB::Appender","DuckDB/Appender.html#method-i-error_message","()","<p>Returns the error message of the appender. If there is no error, then it returns nil.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["execute","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-execute","()",""],["execute_check_state","DuckDB::PendingResult","DuckDB/PendingResult.html#method-i-execute_check_state","()","<p>returns the state of the pending result. the result can be :ready, :not_ready, :error, :no_tasks.\n<p>:ready …\n"],["execute_pending","DuckDB::PendingResult","DuckDB/PendingResult.html#method-i-execute_pending","()","<p>Get DuckDB::Result object after query execution finished.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">conn</span> = <span class=\"ruby-identifier\">db</span>.<span class=\"ruby-identifier\">connect</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["execute_task","DuckDB::PendingResult","DuckDB/PendingResult.html#method-i-execute_task","()","<p>Executes the task in the pending result.\n\n<pre>db = DuckDB::Database.open\nconn = db.connect\npending_result = ...</pre>\n"],["execution_finished?","DuckDB::PendingResult","DuckDB/PendingResult.html#method-i-execution_finished-3F","()",""],["flush","DuckDB::Appender","DuckDB/Appender.html#method-i-flush","()","<p>Flushes the appender to the table, forcing the cache of the appender to be cleared. If flushing the data …\n"],["get_alias","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-get_alias","()","<p>Returns the alias of the logical type.\n"],["get_config_flag","DuckDB::Config","DuckDB/Config.html#method-c-get_config_flag","(p1)",""],["internal_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-internal_type","()","<p>returns logical type’s internal type symbol for Decimal or Enum types ‘:unknown` means that the logical …\n"],["interrupt","DuckDB::Connection","DuckDB/Connection.html#method-i-interrupt","()","<p>Interrupts the currently running query.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">conn</span> = <span class=\"ruby-identifier\">db</span>.<span class=\"ruby-identifier\">connect</span>\n<span class=\"ruby-identifier\">con</span>.<span class=\"ruby-identifier\">query</span>(<span class=\"ruby-string\">&#39;SET ENABLE_PROGRESS_BAR=true&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["iso8601_parse","DuckDB::Interval","DuckDB/Interval.html#method-c-iso8601_parse","(value)","<p>parses the ISO8601 format string and return the Interval object.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Interval</span>.<span class=\"ruby-identifier\">iso8601_parse</span>(<span class=\"ruby-string\">&#39;P1Y2M3DT4H5M6.123456S&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["key_description","DuckDB::Config","DuckDB/Config.html#method-c-key_description","(p1)","<p>returns available configuration name and the description. The return value is array object. The first …\n"],["key_descriptions","DuckDB::Config","DuckDB/Config.html#method-c-key_descriptions","()","<p>returns the Hash object of all available configuration names and the descriptions.\n<p>configs = DuckDB::Config.key_descriptions …\n"],["key_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-key_type","()","<p>Returns the key logical type for map type, otherwise nil.\n"],["library_version","DuckDB","DuckDB.html#method-c-library_version","()","<p>Returns the version of the DuckDB library.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">DuckDB</span>.<span class=\"ruby-identifier\">library_version</span> <span class=\"ruby-comment\"># =&gt; &quot;0.2.0&quot;</span>\n</pre>\n"],["logical_type","DuckDB::Column","DuckDB/Column.html#method-i-logical_type","()","<p>Returns the logical type class.\n"],["member_count","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-member_count","()","<p>Returns the member count of union type, otherwise 0.\n"],["member_name_at","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-member_name_at","(p1)","<p>Returns the name of the union member at the specified index.\n"],["member_type_at","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-member_type_at","(p1)","<p>Returns the logical type of the union member at the specified index as a DuckDB::LogicalType object. …\n"],["mk_interval","DuckDB::Interval","DuckDB/Interval.html#method-c-mk_interval","(year: 0, month: 0, day: 0, hour: 0, min: 0, sec: 0, usec: 0)","<p>creates the Interval object.\n\n<pre>DuckDB::Interval.mk_interval(year: 1, month: 2, day: 3, hour: 4, min: 5, ...</pre>\n"],["name","DuckDB::Column","DuckDB/Column.html#method-i-name","()","<p>Returns the column name.\n"],["new","DuckDB::Appender","DuckDB/Appender.html#method-c-new","(p1, p2, p3)",""],["new","DuckDB::Config","DuckDB/Config.html#method-c-new","()",""],["new","DuckDB::ExtractedStatements","DuckDB/ExtractedStatements.html#method-c-new","(con, sql)",""],["new","DuckDB::ExtractedStatementsImpl","DuckDB/ExtractedStatementsImpl.html#method-c-new","(p1, p2)",""],["new","DuckDB::InstanceCache","DuckDB/InstanceCache.html#method-c-new","()",""],["new","DuckDB::Interval","DuckDB/Interval.html#method-c-new","(interval_months: 0, interval_days: 0, interval_micros: 0)","<p>creates the Interval object. The arguments are the number of months, days, and microseconds. The default …\n"],["new","DuckDB::PendingResult","DuckDB/PendingResult.html#method-c-new","(p1, p2 = v2)",""],["new","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-c-new","(p1, p2)",""],["new","DuckDB::Result","DuckDB/Result.html#method-c-new","()",""],["nparams","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-nparams","()",""],["open","DuckDB::Database","DuckDB/Database.html#method-c-open","(dbpath = nil, config = nil)","<p>Opens database. The first argument is DuckDB database file path to open. If there is no argument, the …\n"],["param_type","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-param_type","(index)","<p>returns parameter type. The argument must be index of parameter.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["parameter_name","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-parameter_name","(p1)",""],["pending_prepared","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-pending_prepared","()",""],["pending_prepared_stream","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-pending_prepared_stream","()",""],["prepare","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-c-prepare","(con, sql)","<p>return DuckDB::PreparedStatement object. The first argument is DuckDB::Connection object. The second …\n"],["prepared_statement","DuckDB::Connection","DuckDB/Connection.html#method-i-prepared_statement","(str, &)","<p>returns PreparedStatement object. The first argument is SQL string. If block is given, the block is executed …\n"],["prepared_statement","DuckDB::ExtractedStatementsImpl","DuckDB/ExtractedStatementsImpl.html#method-i-prepared_statement","(p1, p2)",""],["query","DuckDB::Connection","DuckDB/Connection.html#method-i-query","(sql, *args, **kwargs)","<p>executes sql with args. The first argument sql must be SQL string. The rest arguments are parameters …\n"],["query_multi_sql","DuckDB::Connection","DuckDB/Connection.html#method-i-query_multi_sql","(sql)",""],["query_progress","DuckDB::Connection","DuckDB/Connection.html#method-i-query_progress","()","<p>Returns the progress of the currently running query.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">&#39;duckdb&#39;</span>\n\n<span class=\"ruby-identifier\">db</span> = <span class=\"ruby-constant\">DuckDB</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Database</span>.<span class=\"ruby-identifier\">open</span>\n<span class=\"ruby-identifier\">conn</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["rows_changed","DuckDB::Result","DuckDB/Result.html#method-i-rows_changed","()","<p>Returns the count of rows changed.\n\n<pre>DuckDB::Database.open do |db|\n  db.connect do |con|\n    r = con.query(&#39;CREATE ...</pre>\n"],["scale","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-scale","()","<p>Returns the scale of the decimal column.\n"],["set_alias","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-set_alias","(p1)","<p>Return the set alias of the logical type.\n"],["set_config","DuckDB::Config","DuckDB/Config.html#method-i-set_config","(p1, p2)",""],["size","DuckDB::Config","DuckDB/Config.html#method-c-size","()",""],["size","DuckDB::ExtractedStatementsImpl","DuckDB/ExtractedStatementsImpl.html#method-i-size","()",""],["size","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-size","()","<p>Returns the size of the array column, otherwise 0.\n"],["state","DuckDB::PendingResult","DuckDB/PendingResult.html#method-i-state","()","<p>returns the state of the pending result. the result can be :ready, :not_ready, :error, :no_tasks.\n<p>:ready …\n"],["statement_type","DuckDB::PreparedStatement","DuckDB/PreparedStatement.html#method-i-statement_type","()","<p>returns statement type. The return value is one of the following symbols:\n\n<pre>:invalid, :select, :insert, ...</pre>\n"],["to_interval","DuckDB::Interval","DuckDB/Interval.html#method-c-to_interval","(value)","<p>Convert the value to the Interval object. The value can be String or Interval object. If the value is …\n"],["type","DuckDB::Column","DuckDB/Column.html#method-i-type","()","<p>returns column type symbol ‘:unknown` means that the column type is unknown/unsupported by ruby-duckdb. …\n"],["type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-type","()","<p>returns logical type’s type symbol ‘:unknown` means that the logical type’s type is unknown/unsupported …\n"],["use_chunk_each?","DuckDB::Result","DuckDB/Result.html#method-c-use_chunk_each-3F","()",""],["value_type","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-value_type","()","<p>Returns the value logical type for map type, otherwise nil.\n"],["width","DuckDB::LogicalType","DuckDB/LogicalType.html#method-i-width","()","<p>Returns the width of the decimal column.\n"],["CHANGELOG","","CHANGELOG_md.html","","<p>Changelog\n<p>All notable changes to this project will be documented in this file.\n<p>Unreleased\n"],["CONTRIBUTION","","CONTRIBUTION_md.html","","<p>Contribution Guide\n<p>Environment setup\n<p>With docker\n"],["LICENSE","","LICENSE.html","","<p>MIT License\n<p>Copyright © 2019 suketa\n<p>Permission is hereby granted, free of charge, to any person obtaining …\n"],["README","","README_md.html","","<p>ruby-duckdb\n<p><img src=\"https://github.com/suketa/ruby-duckdb/workflows/Ubuntu/badge.svg\">\n<img src=\"https://github.com/suketa/ruby-duckdb/workflows/MacOS/badge.svg\"> ...\n"]]}}